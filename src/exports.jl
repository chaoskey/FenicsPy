############################################
#
#    dolfin.cpp.la
#
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/cpp/la/index.html
#
############################################

@pyclass dolfin Matrix FeObject FeMatrix
@pyclass dolfin Vector FeObject FeVector
@pyclass dolfin PETScVector FeVector
@pyclass dolfin PETScMatrix FeMatrix
@pyclass dolfin EigenVector FeVector
@pyclass dolfin EigenMatrix FeMatrix
@pyclass dolfin LUSolver
@pyclass dolfin SLEPcEigenSolver
@pyclass dolfin KrylovSolver

@pyfunc dolfin as_tensor
@pyfunc dolfin as_vector
@pyfunc dolfin as_matrix

export FeMatrix, FeVector, PETScVector, PETScMatrix, EigenVector, EigenVector,
          LUSolver, SLEPcEigenSolver, KrylovSolver, 
          as_tensor, as_vector, as_matrix

############################################
#
#    dolfin.cpp.function
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.function.html   
#
#    dolfin.function
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/functions/index.html
#
############################################

@pyclass dolfin Expression
@pyclass dolfin Constant Expression
@pyclass ufl FacetNormal Expression
@pyclass dolfin Function FeObject FeFunction
@pyclass dolfin FunctionSpace

@pyfunc dolfin interpolate
@pyfunc dolfin VectorFunctionSpace
@pyfunc dolfin TrialFunction
@pyfunc dolfin TestFunction
@pyfunc dolfin TestFunctions

export Constant, Expression, FeFunction, FunctionSpace, FacetNormal, 
       interpolate, VectorFunctionSpace, TrialFunction, TestFunction, TestFunctions

############################################
#
#    dolfin.mesh
#    dolfin.cpp.mesh module
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.mesh.html
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/cpp/mesh/index.html
#
############################################

# export
@pyclass dolfin Mesh
@pyclass dolfin MeshFunction
@pyclass dolfin SubDomain
@pyclass dolfin CompiledSubDomain

# no need to export
@pyclass dolfin MeshDomains

export Mesh, MeshFunction, SubDomain, CompiledSubDomain

############################################
#
#    dolfin.cpp.generation
#
# https://fenicsproject.org/docs/dolfin/latest/python/_autogenerated/dolfin.cpp.generation.html
#
############################################

@pyclass dolfin BoxMesh
@pyclass dolfin IntervalMesh
@pyclass dolfin RectangleMesh
@pyclass dolfin SphericalShellMesh
@pyclass dolfin UnitCubeMesh
@pyclass dolfin UnitDiscMesh
@pyclass dolfin UnitIntervalMesh
@pyclass dolfin UnitSquareMesh
@pyclass dolfin UnitTriangleMesh

export BoxMesh, IntervalMesh, RectangleMesh, SphericalShellMesh, UnitCubeMesh, UnitDiscMesh, UnitIntervalMesh, UnitSquareMesh, UnitTriangleMesh

############################################
#
#    dolfin.cpp.fem
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.fem.html
#
#    dolfin.fem module
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/fem/index.html
#
############################################

@pyclass dolfin LinearVariationalProblem
@pyclass dolfin LinearVariationalSolver
@pyclass dolfin NonlinearVariationalProblem
@pyclass dolfin NonlinearVariationalSolver
@pyclass dolfin DirichletBC

@pyfunc dolfin assemble
@pyfunc dolfin errornorm
@pyfunc dolfin project
@pyfunc dolfin solve

# Base: split
function split(fun::FeFunction)
     vec = dolfin.split(fun.pyobject)
     expr_vec = [FeFunction(spl) for spl in vec]
     return expr_vec
end

export LinearVariationalProblem, LinearVariationalSolver, NonlinearVariationalProblem, NonlinearVariationalSolver, DirichletBC, 
       assemble, errornorm, project, solve

############################################
#
#    dolfin.cpp.geometry
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.geometry.html
#
############################################

@pyclass dolfin Point
export Point

############################################
#
#    dolfin.common
#
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/common/index.html
#
############################################

@pyfunc dolfin plot
export plot

############################################
#
#    ufi Cells
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html#module-ufl.cell
#
############################################

# no need to export
@pyclass ufl Cell

############################################
#
#    ufi Elements    
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.finiteelement.html
#
############################################

@pyclass dolfin FiniteElement
@pyclass dolfin MixedElement

export FiniteElement, MixedElement

############################################
#
#    ufi Expression
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
#
############################################

# no need to export
@pyclass ufl Argument Expression
@pyclass dolfin Form Expression

# no need to export
# not exported in `feincs` and `ufl` 
@pyclass dolfin Equation Expression

# export 
@pyclass dolfin Measure
@pyclass dolfin Identity Expression
@pyfunc dolfin lhs
@pyfunc dolfin rhs

export Measure, Identity, lhs, rhs

############################################
#
#    ufi Operator
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < Operator < Expr 
############################################

# no need to export
@pyclass dolfin ListTensor Expression
@pyclass dolfin ComponentTensor Expression
@pyclass dolfin Indexed Expression
@pyclass dolfin Variable Expression

# export
@pyfunc dolfin variable

export variable

############################################
#
#    ufi : Tensor algebra operators
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < CompoundTensorOperator < Operator < Expr 
############################################

OpType = Union{Expression, FeFunction}

# no need to export
# not exported in `feincs` or `ufl`
@pyclass ufl Outer Expression
@pyclass ufl Inner Expression
@pyclass ufl Conj Expression
@pyclass ufl Dot Expression
@pyclass ufl Cross Expression
@pyclass ufl Determinant Expression
@pyclass ufl Inverse Expression
@pyclass ufl Cofactor Expression
@pyclass ufl Transposed Expression
@pyclass ufl Trace Expression
@pyclass ufl Deviatoric Expression
@pyclass ufl Skew Expression
@pyclass ufl Sym Expression

# export
@pyfunc dolfin outer
@pyfunc dolfin inner
@pyfunc dolfin dot
@pyfunc dolfin cross
@pyfunc ufl perp
@pyfunc dolfin det
inv(u::OpType) = Inverse(dolfin.inv(u.pyobject)) # Base.inv
@pyfunc ufl cofac
transpose(u::OpType) = Transposed(ufl.transpose(u.pyobject)) # Base.transpose
@pyfunc dolfin tr
@pyfunc ufl diag
@pyfunc ufl diag_vector
@pyfunc dolfin dev
@pyfunc dolfin skew
@pyfunc dolfin sym

export outer, inner, dot, cross, perp, det, cofac, tr, diag, diag_vector, dev, skew, sym

############################################
# Differential operators
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < CompoundDerivative < Derivative < Operator < Expr
############################################

# no need to export
# not exported in `feincs` or `ufl`
@pyclass ufl VariableDerivative Expression
@pyclass ufl Grad Expression
@pyclass ufl Div Expression
@pyclass ufl NablaGrad Expression
@pyclass ufl NablaDiv Expression
@pyclass ufl Curl Expression

# export
diff(f::OpType,v::Variable) = VariableDerivative(dolfin.diff(f.pyobject, v.pyobject))  # Base.diff
@pyfunc dolfin derivative
@pyfunc dolfin grad
div(u::OpType) = Div(dolfin.div(u.pyobject)) # Base.div
@pyfunc dolfin nabla_grad
@pyfunc ufl nabla_div
@pyfunc dolfin Dx
@pyfunc ufl Dn
@pyfunc dolfin curl
@pyfunc ufl rot

export diff, derivative, grad, nabla_div, nabla_grad, Dx, Dn, curl, rot

############################################
# Nonlinear functions
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
############################################

@pyclass ufl Ln Expression 
@pyclass ufl Erf Expression

@pyfunc ufl max_value
@pyfunc ufl min_value
abs(u::OpType) = Expression(dolfin.abs(u.pyobject)) # Base.abs
sign(u::OpType) = Expression(dolfin.sign(u.pyobject)) # Base.sign
sqrt(u::OpType) = Expression(dolfin.sqrt(u.pyobject)) # Base.sqrt
exp(u::OpType) = Expression(dolfin.exp(u.pyobject)) # Base.exp
@pyfunc dolfin ln
@pyfunc dolfin erf
cos(u::OpType) = Expression(dolfin.cos(u.pyobject)) # Base.cos
sin(u::OpType) = Expression(dolfin.sin(u.pyobject)) # Base.sin
tan(u::OpType) = Expression(dolfin.tan(u.pyobject)) # Base.tan
acos(u::OpType) = Expression(dolfin.acos(u.pyobject)) # Base.acos
asin(u::OpType) = Expression(dolfin.asin(u.pyobject)) # Base.asin
atan(u::OpType) = Expression(dolfin.atan(u.pyobject)) # Base.atan
#@pyfunc ufl atan_2
cosh(u::OpType) = Expression(dolfin.cosh(u.pyobject)) # Base.cosh
sinh(u::OpType) = Expression(dolfin.sinh(u.pyobject)) # Base.sinh
tanh(u::OpType) = Expression(dolfin.tanh(u.pyobject)) # Base.tanh
#@pyfunc dolfin bessel_J
#@pyfunc dolfin bessel_Y
#@pyfunc dolfin bessel_I
#@pyfunc dolfin bessel_K

export max_value, min_value, ln, erf, atan_2, bessel_J, bessel_Y, bessel_I, bessel_K

############################################
#    Operator
############################################

#import Base: +, -, *, /, ^, ==, <<   # must be explicitly imported to be extended

*(expr1::OpType , expr2::Measure) = Expression(expr2.pyobject.__rmul__(expr1.pyobject) )

*(expr1::OpType , expr2::OpType ) = Expression(expr1.pyobject.__mul__(expr2.pyobject) )
*(expr1::Real, expr2::OpType) = Expression(expr2.pyobject.__mul__(expr1) )
*(expr1::OpType , expr2::Real) = Expression(expr1.pyobject.__mul__(expr2) )

+(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__add__(expr2) )
+(expr1::Real, expr2::OpType) = Expression(expr2.pyobject.__add__(expr1) )
+(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__add__(expr2.pyobject) )

-(expr::OpType) = (-1)*expr
-(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__sub__(expr2) )
-(expr1::Real, expr2::OpType) = (-1)*(Expression(expr2.pyobject.__sub__(expr1) ))
-(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__sub__(expr2.pyobject) )

/(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__div__(expr2) )
/(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__div__(expr2.pyobject) )
/(expr1::Real,expr2::OpType) = Constant(expr1) / expr2

^(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__pow__(expr2) )
^(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__pow__(expr2.pyobject) )


==(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject == expr2.pyobject)
==(expr1::OpType, expr2::Real) = Expression(expr1.pyobject == expr2)
==(expr1::Real, expr2::OpType) = Expression(expr2.pyobject == expr1)

############################################
#
#    mshr
#
# https://bitbucket.org/dolfin-project/mshr/wiki/Home
#
############################################

# no need to export
@pyclass mshr CSGGeometry

# 2D primitives
@pyclass mshr Rectangle CSGGeometry
@pyclass mshr Circle CSGGeometry
@pyclass mshr Polygon CSGGeometry
@pyclass mshr Ellipse CSGGeometry

# 3D primitives
@pyclass mshr Cylinder CSGGeometry
@pyclass mshr Box CSGGeometry
@pyclass mshr Surface3D CSGGeometry
@pyclass mshr Cone CSGGeometry
@pyclass mshr Ellipsoid CSGGeometry
@pyclass mshr Sphere CSGGeometry
@pyclass mshr Tetrahedron CSGGeometry

@pyfunc mshr generate_mesh

+(geo1::CSGGeometry, geo2::CSGGeometry) = CSGGeometry(geo1.pyobject + geo2.pyobject)
-(geo1::CSGGeometry, geo2::CSGGeometry) = CSGGeometry(geo1.pyobject - geo2.pyobject) 

export Rectangle, Circle, Polygon, Ellipse,
       Cylinder, Box, Surface3D, Cone, Ellipsoid, Sphere, Tetrahedron, 
       generate_mesh

############################################
#
#    dolfin.cpp.io module
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.io.html
#
############################################

@pyclass dolfin File
@pyclass dolfin XDMFFile

<<(file::File, u::Mesh) =  file.pyobject << u.pyobject
<<(file::File, u::FeFunction) =  file.pyobject << u.pyobject
<<(file::File, u::Tuple{FeFunction,Real}) =  file.pyobject <<  (u[1].pyobject, u[2])

export File, XDMFFile

############################################
#
#    dolfin.cpp.adaptivity
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.adaptivity.html?highlight=timeseries#dolfin.cpp.adaptivity.TimeSeries
#
############################################

@pyclass dolfin TimeSeries
export TimeSeries

############################################
#
#    Other
#
############################################

array(vec::Union{FeVector, FeMatrix}) = vec.pyobject.gather_on_zero()
array(form::Expression) =  array(assemble(form)).gather_on_zero()
function array(solution::FeFunction)
    generic_vector = solution.pyobject.vector()
    instantiated_vector = dolfin.Vector(generic_vector)
    instantiated_vector.gather_on_zero()
end

len(U::OpType) = length(U.pyobject)

export array, len

@pyclass dolfin Parameters
@pyclass dolfin GlobalParameters

@pyfunc dolfin list_linear_algebra_backends
@pyfunc dolfin has_linear_algebra_backend
@pyfunc dolfin has_slepc
@pyfunc dolfin info

export list_linear_algebra_backends, has_linear_algebra_backend, has_slepc, info



