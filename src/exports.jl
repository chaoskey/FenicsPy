############################################
#
#    dolfin.cpp.la
#
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/cpp/la/index.html
#
############################################

@pyclass fenics Matrix FeObject FeMatrix
@pyclass fenics Vector FeObject FeVector
@pyclass fenics PETScVector FeVector
@pyclass fenics PETScMatrix FeMatrix
@pyclass fenics LUSolver
@pyclass fenics SLEPcEigenSolver
@pyclass fenics KrylovSolver

@pyfunc fenics as_tensor
@pyfunc fenics as_vector
@pyfunc fenics as_matrix

export FeMatrix, FeVector, PETScVector, PETScMatrix, 
          LUSolver, SLEPcEigenSolver, KrylovSolver, 
          as_tensor, as_vector, as_matrix

############################################
#
#    dolfin.cpp.function
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.function.html   
#
#    dolfin.function
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/functions/index.html
#
############################################

@pyclass fenics Expression
@pyclass fenics Constant Expression
@pyclass ufl FacetNormal Expression
@pyclass fenics Function FeObject FeFunction
@pyclass fenics FunctionSpace

@pyfunc fenics interpolate
@pyfunc fenics VectorFunctionSpace
@pyfunc fenics TrialFunction
@pyfunc fenics TestFunction
@pyfunc fenics TestFunctions

export Constant, Expression, FeFunction, FunctionSpace, FacetNormal, 
       interpolate, VectorFunctionSpace, TrialFunction, TestFunction, TestFunctions

############################################
#
#    dolfin.mesh
#    dolfin.cpp.mesh module
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.mesh.html
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/cpp/mesh/index.html
#
############################################

# export
@pyclass fenics Mesh
@pyclass fenics MeshFunction
@pyclass fenics SubDomain
@pyclass fenics CompiledSubDomain

# no need to export
@pyclass fenics MeshDomains

export Mesh, MeshFunction, SubDomain, CompiledSubDomain

############################################
#
#    dolfin.cpp.generation
#
# https://fenicsproject.org/docs/dolfin/latest/python/_autogenerated/dolfin.cpp.generation.html
#
############################################

@pyclass fenics BoxMesh
@pyclass fenics IntervalMesh
@pyclass fenics RectangleMesh
@pyclass fenics SphericalShellMesh
@pyclass fenics UnitCubeMesh
@pyclass fenics UnitDiscMesh
@pyclass fenics UnitIntervalMesh
@pyclass fenics UnitSquareMesh
@pyclass fenics UnitTriangleMesh

export BoxMesh, IntervalMesh, RectangleMesh, SphericalShellMesh, UnitCubeMesh, UnitDiscMesh, UnitIntervalMesh, UnitSquareMesh, UnitTriangleMesh

############################################
#
#    dolfin.cpp.fem
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.fem.html
#
#    dolfin.fem module
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/fem/index.html
#
############################################

@pyclass fenics LinearVariationalProblem
@pyclass fenics LinearVariationalSolver
@pyclass fenics NonlinearVariationalProblem
@pyclass fenics NonlinearVariationalSolver
@pyclass fenics DirichletBC

@pyfunc fenics assemble
@pyfunc fenics errornorm
@pyfunc fenics project
@pyfunc fenics solve

# Base: split
function split(fun::FeFunction)
     vec = fenics.split(fun.pyobject)
     expr_vec = [FeFunction(spl) for spl in vec]
     return expr_vec
end

export LinearVariationalProblem, LinearVariationalSolver, NonlinearVariationalProblem, NonlinearVariationalSolver, DirichletBC, 
       assemble, errornorm, project, solve

############################################
#
#    dolfin.cpp.geometry
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.geometry.html
#
############################################

@pyclass fenics Point
export Point

############################################
#
#    dolfin.common
#
# https://fenicsproject.org/docs/dolfin/2017.2.0/python/programmers-reference/common/index.html
#
############################################

@pyfunc fenics plot
export plot

############################################
#
#    ufi Cells
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html#module-ufl.cell
#
############################################

# no need to export
@pyclass ufl Cell

############################################
#
#    ufi Elements    
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.finiteelement.html
#
############################################

@pyclass fenics FiniteElement
@pyclass fenics MixedElement

export FiniteElement, MixedElement

############################################
#
#    ufi Expression
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
#
############################################

# no need to export
@pyclass ufl Argument Expression
@pyclass fenics Form Expression

# no need to export
# not exported in `feincs` and `ufl` 
@pyclass fenics Equation Expression

# export 
@pyclass fenics Measure
@pyclass fenics Identity Expression
@pyfunc fenics lhs
@pyfunc fenics rhs

export Measure, Identity, lhs, rhs

############################################
#
#    ufi Operator
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < Operator < Expr 
############################################

# no need to export
@pyclass fenics ListTensor Expression
@pyclass fenics ComponentTensor Expression
@pyclass fenics Indexed Expression
@pyclass fenics Variable Expression

# export
@pyfunc fenics variable

export variable

############################################
#
#    ufi : Tensor algebra operators
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < CompoundTensorOperator < Operator < Expr 
############################################

OpType = Union{Expression, FeFunction}

# no need to export
# not exported in `feincs` or `ufl`
@pyclass ufl Outer Expression
@pyclass ufl Inner Expression
@pyclass ufl Conj Expression
@pyclass ufl Dot Expression
@pyclass ufl Cross Expression
@pyclass ufl Determinant Expression
@pyclass ufl Inverse Expression
@pyclass ufl Cofactor Expression
@pyclass ufl Transposed Expression
@pyclass ufl Trace Expression
@pyclass ufl Deviatoric Expression
@pyclass ufl Skew Expression
@pyclass ufl Sym Expression

# export
@pyfunc fenics outer
@pyfunc fenics inner
@pyfunc fenics dot
@pyfunc fenics cross
@pyfunc ufl perp
@pyfunc fenics det
inv(u::OpType) = Inverse(fenics.inv(u.pyobject)) # Base.inv
@pyfunc ufl cofac
transpose(u::OpType) = Transposed(ufl.transpose(u.pyobject)) # Base.transpose
@pyfunc fenics tr
@pyfunc ufl diag
@pyfunc ufl diag_vector
@pyfunc fenics dev
@pyfunc fenics skew
@pyfunc fenics sym

export outer, inner, dot, cross, perp, det, cofac, tr, diag, diag_vector, dev, skew, sym

############################################
# Differential operators
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
# < CompoundDerivative < Derivative < Operator < Expr
############################################

# no need to export
# not exported in `feincs` or `ufl`
@pyclass ufl VariableDerivative Expression
@pyclass ufl Grad Expression
@pyclass ufl Div Expression
@pyclass ufl NablaGrad Expression
@pyclass ufl NablaDiv Expression
@pyclass ufl Curl Expression

# export
diff(f::OpType,v::Variable) = VariableDerivative(fenics.diff(f.pyobject, v.pyobject))  # Base.diff
@pyfunc fenics derivative
@pyfunc fenics grad
div(u::OpType) = Div(fenics.div(u.pyobject)) # Base.div
@pyfunc fenics nabla_grad
@pyfunc ufl nabla_div
@pyfunc fenics Dx
@pyfunc ufl Dn
@pyfunc fenics curl
@pyfunc ufl rot

export diff, derivative, grad, nabla_div, nabla_grad, Dx, Dn, curl, rot

############################################
# Nonlinear functions
#
# https://fenicsproject.org/docs/ufl/1.6.0/ufl.html
############################################

@pyclass ufl Ln Expression 
@pyclass ufl Erf Expression

@pyfunc ufl max_value
@pyfunc ufl min_value
abs(u::OpType) = Expression(fenics.abs(u.pyobject)) # Base.abs
sign(u::OpType) = Expression(fenics.sign(u.pyobject)) # Base.sign
sqrt(u::OpType) = Expression(fenics.sqrt(u.pyobject)) # Base.sqrt
exp(u::OpType) = Expression(fenics.exp(u.pyobject)) # Base.exp
@pyfunc fenics ln
@pyfunc fenics erf
cos(u::OpType) = Expression(fenics.cos(u.pyobject)) # Base.cos
sin(u::OpType) = Expression(fenics.sin(u.pyobject)) # Base.sin
tan(u::OpType) = Expression(fenics.tan(u.pyobject)) # Base.tan
acos(u::OpType) = Expression(fenics.acos(u.pyobject)) # Base.acos
asin(u::OpType) = Expression(fenics.asin(u.pyobject)) # Base.asin
atan(u::OpType) = Expression(fenics.atan(u.pyobject)) # Base.atan
#@pyfunc ufl atan_2
cosh(u::OpType) = Expression(fenics.cosh(u.pyobject)) # Base.cosh
sinh(u::OpType) = Expression(fenics.sinh(u.pyobject)) # Base.sinh
tanh(u::OpType) = Expression(fenics.tanh(u.pyobject)) # Base.tanh
#@pyfunc fenics bessel_J
#@pyfunc fenics bessel_Y
#@pyfunc fenics bessel_I
#@pyfunc fenics bessel_K

export max_value, min_value, ln, erf, atan_2, bessel_J, bessel_Y, bessel_I, bessel_K

############################################
#    Operator
############################################

#import Base: +, -, *, /, ^, ==, <<   # must be explicitly imported to be extended

*(expr1::OpType , expr2::Measure) = Expression(expr2.pyobject.__rmul__(expr1.pyobject) )

*(expr1::OpType , expr2::OpType ) = Expression(expr1.pyobject.__mul__(expr2.pyobject) )
*(expr1::Real, expr2::OpType) = Expression(expr2.pyobject.__mul__(expr1) )
*(expr1::OpType , expr2::Real) = Expression(expr1.pyobject.__mul__(expr2) )

+(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__add__(expr2) )
+(expr1::Real, expr2::OpType) = Expression(expr2.pyobject.__add__(expr1) )
+(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__add__(expr2.pyobject) )

-(expr::OpType) = (-1)*expr
-(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__sub__(expr2) )
-(expr1::Real, expr2::OpType) = (-1)*(Expression(expr2.pyobject.__sub__(expr1) ))
-(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__sub__(expr2.pyobject) )

/(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__div__(expr2) )
/(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__div__(expr2.pyobject) )
/(expr1::Real,expr2::OpType) = (expr1 * expr2) / (expr2 * expr2)

^(expr1::OpType, expr2::Real) = Expression(expr1.pyobject.__pow__(expr2) )
^(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject.__pow__(expr2.pyobject) )


==(expr1::OpType, expr2::OpType) = Expression(expr1.pyobject == expr2.pyobject)
==(expr1::OpType, expr2::Real) = Expression(expr1.pyobject == expr2)
==(expr1::Real, expr2::OpType) = Expression(expr2.pyobject == expr1)

############################################
#
#    mshr
#
# https://bitbucket.org/fenics-project/mshr/wiki/Home
#
############################################

# no need to export
@pyclass mshr CSGGeometry

# 2D primitives
@pyclass mshr Rectangle CSGGeometry
@pyclass mshr Circle CSGGeometry
@pyclass mshr Polygon CSGGeometry
@pyclass mshr Ellipse CSGGeometry

# 3D primitives
@pyclass mshr Cylinder CSGGeometry
@pyclass mshr Box CSGGeometry
@pyclass mshr Surface3D CSGGeometry
@pyclass mshr Cone CSGGeometry
@pyclass mshr Ellipsoid CSGGeometry
@pyclass mshr Sphere CSGGeometry
@pyclass mshr Tetrahedron CSGGeometry

@pyfunc mshr generate_mesh

+(geo1::CSGGeometry, geo2::CSGGeometry) = CSGGeometry(geo1.pyobject + geo2.pyobject)
-(geo1::CSGGeometry, geo2::CSGGeometry) = CSGGeometry(geo1.pyobject - geo2.pyobject) 

export Rectangle, Circle, Polygon, Ellipse,
       Cylinder, Box, Surface3D, Cone, Ellipsoid, Sphere, Tetrahedron, 
       generate_mesh

############################################
#
#    dolfin.cpp.io module
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.io.html
#
############################################

@pyclass fenics File
@pyclass fenics XDMFFile

<<(file::File, u::Mesh) =  file.pyobject << u.pyobject
<<(file::File, u::FeFunction) =  file.pyobject << u.pyobject
<<(file::File, u::Tuple{FeFunction,Real}) =  file.pyobject <<  (u[1].pyobject, u[2])

export File, XDMFFile

############################################
#
#    dolfin.cpp.adaptivity
#
# https://fenicsproject.org/docs/dolfin/2018.1.0/python/_autogenerated/dolfin.cpp.adaptivity.html?highlight=timeseries#dolfin.cpp.adaptivity.TimeSeries
#
############################################

@pyclass fenics TimeSeries
export TimeSeries

############################################
#
#    Other
#
############################################

array(vec::Union{FeVector, FeMatrix}) = vec.pyobject.gather_on_zero()
array(form::Expression) =  array(assemble(form)).gather_on_zero()
function array(solution::FeFunction)
    generic_vector = solution.pyobject.vector()
    instantiated_vector = fenics.Vector(generic_vector)
    instantiated_vector.gather_on_zero()
end

len(U::OpType) = length(U.pyobject)

export array, len


@pyfunc fenics has_linear_algebra_backend
@pyfunc fenics has_slepc

export has_linear_algebra_backend, has_slepc



